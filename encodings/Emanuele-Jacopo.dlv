% INPUT:
% pawn(x, y, pawn_index, team | enemy)
% tile(x, y, level)


% ------------------------------------------------------------------------
% GUESS

movePawn(Index, X, Y) | dontMovePawn(Index, X, Y):- pawn(X, Y, Index, team).

% sposto in modo casuale la pedina scelta con la regola movePawn
moveIn(Pawn, X-1, Y-1) | moveIn(Pawn, X-1, Y) | moveIn(Pawn, X-1, Y+1) | moveIn(Pawn, X, Y+1) | moveIn(Pawn, X+1, Y+1) | moveIn(Pawn, X+1, Y) | moveIn(Pawn, X+1, Y-1) | moveIn(Pawn, X, Y-1):- movePawn(Pawn, X, Y).

% inserisco un nuovo livello in modo casuale su una cella vicina
placeIn(X-1, Y-1) | placeIn(X-1, Y) | placeIn(X-1, Y+1) | placeIn(X, Y+1) | placeIn(X+1, Y+1) | placeIn(X+1, Y) | placeIn(X+1, Y-1) | placeIn(X, Y-1):- moveIn(_, X, Y).

% ------------------------------------------------------------------------
% CHECK
% QUI ANDRANNO SOLO I VINCOLI PER FAR SI CHE GIOCHI SENZA INFRANGERE LE REGOLE

% decido di spostare una sola pedina in modo casuale
:- #count{I,X,Y: movePawn(I,X,Y)} != 1.

% non posso spostare una pedina fuori dai bordi (cioè se non esiste una cella)
:- moveIn(_, X, Y), not existsTile(X, Y).

% non posso spostare una pedina su una cella di livello 4
:- moveIn(_, X, Y), tile(X, Y, 4).

% non posso spostare una pedina su una cella di livello > livello della cella attuale + 1
:- movePawn(Index, X, Y), tile(X, Y, L), moveIn(Index, X1, Y1), tile(X1, Y1, L1), L1 > L+1.

% non posso incrementare una cella di livello 4
:- placeIn(X, Y), tile(X, Y, 4).

% non posso spostarmi su una cella già occupata da una pedina
:- moveIn(_, X, Y), existsPawn(X, Y).

% non posso incrementare il livello di una cella che non esiste 
:- placeIn(X, Y), not existsTile(X, Y).

% non posso incrementare il livello di una cella già occupata da una pedina

:- placeIn(X, Y), tileWithOtherPawn(X, Y).

% ------------------------------------------------------------------------
% OPTIMIZE

% HIGH PRIORITY: 

% massimizzare il movimento su celle di livello 3
:~ moveIn(_, X, Y), tile(X, Y, L). [3-L@9, X,Y]

% pago se incremento una cella di livello 2 al livello 3 (liv 2->3) vicino alla quale c'è una pedina nemica su cella di livello 2
:~ placeIn(X, Y), tile(X, Y, 2), enemyNextToTile(X, Y, 2, L1), L1>=2. [1@8, X,Y]

% pago se NON incremento una cella di livello 3 al livello 4 (liv 3->4) vicino alla quale c'è una pedina nemica su cella di livello 2
:~ not placeIn(X, Y), tile(X, Y, 3), enemyNextToTile(X, Y, 3, L), L>=2. [1@7, X,Y]


% MID PRIORITY: 

% minimizzare il numero di celle adiacenti su cui la pedina non può spostarsi
:~ moveIn(_, X, Y), tile(X, Y, L), numAdjacentReachableTiles(X, Y, C). [8-C@6, X,Y]

% minimizzare la distanza dalla cella migliore del nemico 
:~ bestEnemyPawn(X1,Y1), moveIn(_, X, Y), minMovesFromToTiles(X, Y, X1, Y1, C). [C@5, X,Y]

% minimizzare la creazione di celle di livello 4
:~ placeIn(X,Y), tile(X, Y, L), L=3. [1@4, X,Y]


% LOW PRIORITY:

% massimizzare la creazione di celle di livello 3
:~ placeIn(X, Y), tile(X, Y, L), L<3. [3-L@3, X,Y]

% - minimizzare numero di celle adiacenti di livello 4
:~ moveIn(_, X, Y), adjacentTileLevelAfterMove(X, Y, _, _, 4). [1@2, X,Y]

% - massimizzare somma di livelli di celle adiacenti
:~ moveIn(_, X, Y), sumAdjacentTileLevelAfterMove(X, Y, Z). [32-Z@1, X,Y]


% PREDICATI DI SUPPORTO:

existsTile(X, Y):- tile(X, Y, _).

existsPawn(X, Y):- pawn(X, Y, _, _).

tileWithOtherPawn(X, Y):- dontMovePawn(_, X, Y).

tileWithOtherPawn(X, Y):- pawn(X, Y, _, enemy).

adjacentTiles(X, Y, X1, Y1):- tile(X, Y, L), tile(X1, Y1, L1), X1 >= X-1, X1 <= X+1, Y1 >= Y-1, Y1 <= Y+1, L!=4, L1!=4, not sameTile(X,Y,X1,Y1).

sumAdjacentTilesLevel(X, Y, TOT, Index, Team):- pawn(X, Y, Index, Team), tile(X,Y,L), #sum{L1,X1,Y1: tile(X1, Y1, L1), adjacentTiles(X,Y,X1,Y1), L1!=0, L1!=4} = C, TOT=C+L.

bestEnemyPawn(X1,Y1) :- #max{C,I : sumAdjacentTilesLevel(X,Y,C,I,enemy), pawn(X,Y,I,enemy), not blockedPawn(X,Y)} = M, sumAdjacentTilesLevel(X1,Y1,M,_,_).

sameTile(X1, Y1, X2, Y2):- tile(X1, Y1, _), tile(X2, Y2, _), X1 = X2, Y1 = Y2.

enemyNextToTile(X, Y, L, L1):- tile(X, Y, L), pawn(X1, Y1, _, enemy), tile(X1, Y1, L1), not sameTile(X, Y, X1, Y1), X1 >= X-1, X1 <= X+1, Y1 >= Y-1, Y1 <= Y+1. 

adjacentTileLevelAfterMove(X, Y, X1, Y1, L):- moveIn(_, X, Y), tile(X1, Y1, L), X1 >= X-1, X1 <= X+1, Y1 >= Y-1, Y1 <= Y+1.

sumAdjacentTileLevelAfterMove(X, Y, C):- #sum{L1,X1,Y1: adjacentTileLevelAfterMove(X, Y, X1, Y1, L1), moveIn(_, X, Y)} = C, tile(X, Y, L).

blockedPawn(X,Y) :- pawn(X, Y, Index, Team), #count{X1,Y1 : adjacentReachableTiles(X,Y,X1,Y1)} = 0.

blockedPawnAfterMove(X,Y) :- tile(X, Y, _), #count{X1,Y1 : adjacentReachableTiles(X,Y,X1,Y1)} = 0.

numAdjacentReachableTiles(X, Y, C):- #count{X1,Y1: adjacentReachableTiles(X, Y, X1, Y1)} = C, moveIn(_, X, Y). 

adjacentReachableTiles(X, Y, X1, Y1):- tile(X, Y, L), tile(X1, Y1, L1), L >= L1-1, X1 >= X-1, X1 <= X+1, Y1 >= Y-1, Y1 <= Y+1, L!=4, L1!=4, not sameTile(X,Y,X1,Y1).

tileReachesInMoves(X, Y, X1, Y1, 1):- tile(X, Y, _), tile(X1, Y1, _), adjacentReachableTiles(X, Y, X1, Y1).

tileReachesInMoves(X, Y, X2, Y2, C):- tile(X, Y, _), tileReachesInMoves(X, Y, X1, Y1, C1), adjacentReachableTiles(X1, Y1, X2, Y2), C=C1+1, size(S), C1 < S. 

% CAMMINO MINIMO A-B: per ogni coppia di celle (A, B) calcolo il numero minimo di passi da fare per raggiungere B, partendo da A.
minMovesFromToTiles(X, Y, X1, Y1, C):- #min{C1: tileReachesInMoves(X, Y, X1, Y1, C1)} = C, moveIn(_, X, Y), tile(X1, Y1, _).

% ------------------------------------------------------------------------
% OUTPUT: move(pawn_index, move_to_x, move_to_y, place_tile_in_x, place_tile_in_y)
% Soluzione finale:
move(Pawn, X, Y, X1, Y1):- moveIn(Pawn, X, Y), placeIn(X1, Y1).